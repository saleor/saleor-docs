---
title: Composable
sidebar_position: 1
---

Most commerce software evokes images of monolithic systems—perhaps extended through plugins—that implement all necessary functionality in a single codebase. Such systems are simpler to set up and easier to understand, but they have a critical shortcoming: if you need to change a single component, you may need to change the entire system.

## Higher Adaptability

Any function not achievable through the core feature set or delegation APIs (plugins, extensions, etc.) either becomes a compromise you accept or disqualifies the entire system. Re-platforming the whole organization is a painful process.

Organizations often undergo platform changes cyclically, rebuilding their commerce solution from scratch every five to ten years. Internal pressure pushes for more frequent changes as platforms lack necessary competitive functions. Meanwhile, leadership pushes for longer periods since every change is costly and disruptive.

For larger companies, we believe a more modular architecture is better. If monolithic software is a single program, composable architectures are like an operating system with multiple specialized programs. Each program focuses on its area of responsibility and delegates other tasks to adjacent systems.

This modularity has costs: more moving parts create inevitable complexity. However, when one component becomes insufficient, you only need to replace that single component and its connections to adjacent systems. Through clever application of the strangler pattern, you can evolve the architecture without disrupting other teams and business units. While not free or painless, the scope of every change is much smaller, timelines are shorter, and risks are easier to contain.

This approach can lead to greater autonomy and efficiency for organizational units. The benefits of enabling teams to choose their tools can quickly outweigh the one-time cost of integrating them.

## Shared Responsibility

Open-source software can counter the problem of outgrowing a monolith by allowing customization beyond the authors' original intentions. This is technically true—you can hire software engineers to modify the source code.

However, every modification takes you further from the original system. Upgrading becomes harder, if not impossible, as you must track every change and modification. Documentation becomes your responsibility since the system no longer behaves as originally designed. If anything goes wrong, you may be the only organization in the world using your unique set of modifications.

Composable architectures allow strict responsibility boundaries across different delegation paths. Each system is maintained by its respective vendor or team, and each system can be upgraded independently as long as the delegation API contracts remain intact. This lets you mix SaaS vendors with on-premise solutions, getting the benefits of both managed services with their SLAs and custom software with unquestionable flexibility—without owning the entire software stack.

## Lower TCO

This benefit is crucial for another reason. For most organizations, owning software is not a goal—it's a compromise. Unless you work for a software house or software conservancy, maintaining software and necessary infrastructure is a recurring cost that should be applied sparingly, where it helps differentiate your business and directly benefits your customers.