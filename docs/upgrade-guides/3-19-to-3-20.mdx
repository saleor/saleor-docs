---
title: Upgrading From 3.19 To 3.20
sidebar_position: 11
---

:::info
To follow the zero-downtime strategy when upgrading to 3.20, **It is recommended to first migrate to latest 3.19.X** and turn on the Celery worker to process all data migrations asynchronously.
Otherwise, you will need to downtime your solution to ensure correct data migration.
:::

## Private media storage

Since Saleor 3.20 webhook event delivery payloads are stored as files using dedicated private storage.
Make sure `PRIVATE_FILE_STORAGE` is configured properly in `settings.py` before upgrade. 

Please refer to [Amazon S3](../setup/media-s3) or [Google Cloud Storage (GCS)](../setup/media-gcs) guidelines if you are using cloud storage.

## Automatic checkout completion

Saleor 3.20 added new functionality to automatically complete `Checkout` that have been paid by the customer.

To learn more, about how this feature works and how to enable it, [read the Automatic Checkout completion docs](/developer/payments/transactions.mdx#automatic-checkout-completion).

:::info
By "paid" in this guide we mean that the `TransactionItems` connected to `Checkout` have fully covered [`Checkout.totalPrice`](/api-reference/checkout/objects/checkout.mdx#checkouttotalpricetaxedmoney---), which means that [`Checkout.authorizeStatus`](/api-reference/checkout/objects/checkout.mdx#checkoutauthorizestatuscheckoutauthorizestatusenum---) is set to [`FULL`](/api-reference/checkout/enums/checkout-authorize-status-enum.mdx).

Learn more about this in [Transaction docs](/developer/payments/transactions.mdx#automatic-checkout-completion)
:::

This feature is **disabled** after migration, and needs to be enabled manually in the [channel settings](/developer/channels/configuration.mdx#settings).

New Saleor instances created from version 3.20 onwards will have this feature **enabled by default**.

This removes the need for storefront implementation to call `checkoutComplete` mutation in order to create `Order`.

Previously a store might have had missing orders, due to `checkoutComplete` mutation not being always called. This could have happened for many unexpected reasons: network issues, storefront bug, customer leaving website, closing tab before being redirected from payment provider, etc.

:::tip
Before Saleor 3.20 you might have used other measures to mitigate missing orders issue, for example by using `CHECKOUT_FULLY_PAID` webhook and calling `checkoutComplete` mutation on your backend.

After migrating to Saleor 3.20 and enabling this feature for all your channels, you can safely get rid of this workaround.

Keep in mind that `CHECKOUT_FULLY_PAID` webhook would have only been triggered if you also used `TransactionFlowStrategy.CHARGE` for your channel. Automatic checkout completion doesn't have this problem.
:::


### Before you enable this feature


:::danger
Enabling this feature might break your current storefront implementation and services connected to Saleor that use `Checkout` object.
:::

Before you enable this feature make sure that you don't rely on any `Checkout` query or mutation that updates `Checkout` after transaction is created.

:::tip
After calling `transactionInitialize` or `transactionProcess` you can determine if `Checkout` has been completed by checking the `TransactionEvent` object returned in the mutation response.

Transaction is considered "paid" when it has one of the following `types`:

- `AUTHORIZATION_SUCCESS`
- `AUTHORIZATION_REQUEST`
- `CHARGE_SUCCESS`
- `CHARGE_REQUEST`

and it's `amount` is equal to `Checkout.totalPrice`.

Note that payment provider might return **lower** amount than the one you have requested (in that case `Checkout` is not paid). Your logic also needs to take into consideration multiple Transactions if you use split-payments.
:::

:::tip
You can also determine if `Checkout` has been paid by calling `checkoutComplete` mutation.

If it returns `Order` object, it means that it was paid and an `Order` was created.

If it returns error, it means that `Checkout` hasn't been paid:

```graphql
mutation CompleteCheckout($id: ID!) {
  checkoutComplete(id: $id) {
    errors {
      code
    }
  }
}
```

will return

```json
{
  "checkoutComplete": {
    "errors": [
      {
        "code": "CHECKOUT_NOT_FULLY_PAID"
      }
    ]
  }
}
```
:::

Automatic checkout completion works just like calling `checkoutComplete` mutation, which deletes `Checkout` object and creates `Order`.

In order to get the `Order` details after payment you can use:

1. **`checkoutComplete` mutation**

:::note
This query can be called directly by customers in a storefront.
:::

This mutation is idempotent, which means it can be called multiple times, but only one `Order` will be created. If `checkoutComplete` is invoked multiple times it will return the same `Order` object.

```graphql
mutation CompleteCheckout($id: ID!) {
  checkoutComplete(id: $id) {
    order {
      id
    }
  }
}
```

2. **`orders` query**

:::note
This query requires <span class="badge badge--danger">MANAGE_ORDERS</span> permission, it cannot be used directly by customers in a storefront.
:::

`orders` query filter, has an option to provide `checkoutIds` or `checkoutTokens` to get `Order` object that was created by specified `Checkout`:

```graphql
query OrderDetails($checkoutId: ID!) {
  orders(filter: {checkoutIds: [$checkoutId]}, first: 1) {
    edges {
      node {
        id
      }
    }
  }
}
```

```graphql
query OrderDetails($checkoutToken: UUID!) {
  orders(filter: {checkoutTokens: [$checkoutToken]}, first: 1) {
    edges {
      node {
        id
      }
    }
  }
}
```

:::warning
Theoretically there could be multiple `Order` objects created from a single `Checkout`. This is why this query uses `first: 1` parameter.

This can happen if [`orderCreateFromCheckout`](/api-reference/orders/mutations/order-create-from-checkout.mdx) mutation is used with [`removeCheckout: false`](/api-reference/orders/mutations/order-create-from-checkout.mdx#ordercreatefromcheckoutremovecheckoutboolean--).

Such case doesn't apply to `checkoutComplete` mutation or automatic checkout completions, thus we can safely assume that only one `Order` can be created from `Checkout`
:::
